package status

import (
	"fmt"
	apimeta "k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// ZncdataStatus defines the common state of Zncdata
type ZncdataStatus struct {
	// +kubebuilder:validation:Optional
	Conditions []metav1.Condition `json:"conditions,omitempty"`
	// +kubebuilder:validation:Optional
	URLs       []URL  `json:"urls,omitempty"`
	Generation int64  `json:"generation,omitempty"`
	Name       string `json:"name,omitempty"`
	Type       string `json:"type,omitempty"`
}

// IsAvailable returns true if the status is available.
func (status *ZncdataStatus) IsAvailable() bool {
	return apimeta.IsStatusConditionTrue(status.Conditions, ConditionTypeAvailable)
}

// SetStatusCondition sets the status condition.
func (status *ZncdataStatus) SetStatusCondition(condition metav1.Condition) (updated bool) {
	// if the condition already exists, update it
	existingCondition := apimeta.FindStatusCondition(status.Conditions, condition.Type)
	if existingCondition == nil {
		condition.ObservedGeneration = status.GetGeneration()
		condition.LastTransitionTime = metav1.Now()
		conditions := status.Conditions
		status.Conditions = append(conditions, condition)
		updated = true
	} else if existingCondition.Status != condition.Status || existingCondition.Reason != condition.Reason || existingCondition.Message != condition.Message {
		existingCondition.Status = condition.Status
		existingCondition.Reason = condition.Reason
		existingCondition.Message = condition.Message
		existingCondition.ObservedGeneration = status.GetGeneration()
		existingCondition.LastTransitionTime = metav1.Now()
		updated = true
	}
	return
}

// InitStatusConditions initializes the status conditions to the provided conditions.
func (status *ZncdataStatus) InitStatusConditions() {
	status.Conditions = []metav1.Condition{}
	status.SetStatusCondition(metav1.Condition{
		Type:               ConditionTypeProgressing,
		Status:             metav1.ConditionTrue,
		Reason:             ConditionReasonPreparing,
		Message:            fmt.Sprintf("%s is preparing", status.Type),
		ObservedGeneration: status.GetGeneration(),
		LastTransitionTime: metav1.Now(),
	})
	status.SetStatusCondition(metav1.Condition{
		Type:               ConditionTypeAvailable,
		Status:             metav1.ConditionFalse,
		Reason:             ConditionReasonPreparing,
		Message:            fmt.Sprintf("%s is preparing", status.Type),
		ObservedGeneration: status.GetGeneration(),
		LastTransitionTime: metav1.Now(),
	})
}

// InitStatus initializes the status.
func (status *ZncdataStatus) InitStatus(object client.Object) {
	generation := object.GetGeneration()
	name := object.GetName()
	kind := object.GetObjectKind().GroupVersionKind().Kind
	status.Generation = generation
	status.Name = name
	status.Type = kind
}

// GetGeneration returns the status's generation.
func (status *ZncdataStatus) GetGeneration() int64 {
	return status.Generation
}

// URL is a URL with a name
type URL struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ZncdataStatus) DeepCopyInto(out *ZncdataStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.URLs != nil {
		in, out := &in.URLs, &out.URLs
		*out = make([]URL, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ZncdataStatus.
func (in *ZncdataStatus) DeepCopy() *ZncdataStatus {
	if in == nil {
		return nil
	}
	out := new(ZncdataStatus)
	in.DeepCopyInto(out)
	return out
}
